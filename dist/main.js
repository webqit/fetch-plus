(() => { var dt = Object.defineProperty; var Te = (n, e) => { for (var t in e) dt(n, t, { get: e[t], enumerable: !0 }) }; var Xe = {}; Te(Xe, { FormDataPlus: () => V, HeadersPlus: () => T, LiveResponse: () => Ae, Observer: () => z, RequestPlus: () => xe, ResponsePlus: () => N, URLSearchParamsPlus: () => J, fetchPlus: () => nt }); function b(n) { return !Array.isArray(n) && typeof n == "object" && n } function re(n) { return typeof n } function C(n) { return Array.isArray(n) } function ge(n) { return n === !0 || n === !1 } function ne(n) { return typeof n == "function" } function je(n) { return n === null || n === "" } function G(n) { return arguments.length && (n === void 0 || typeof n > "u") } function g(n) { return Array.isArray(n) || typeof n == "object" && n || ne(n) } function Ie(n) { return je(n) || G(n) || n === !1 || n === 0 || g(n) && !Object.keys(n).length } function B(n) { return ne(n) || n && {}.toString.call(n) === "[object function]" } function se(n) { return n instanceof Number || typeof n == "number" } function $(n) { return se(n) || n !== !0 && n !== !1 && n !== null && n !== "" && !isNaN(n * 1) } function U(n) { return n instanceof String || typeof n == "string" && n !== null } function Ce(n) { return !U(n) && !G(n.length) } function D(n, ...e) { if (!n || !["object", "function"].includes(typeof n)) throw new Error("Argument #1 must be of type object"); let t = n[Symbol.for("wq")]; if (t || (t = new ye, Object.defineProperty(n, Symbol.for("wq"), { value: t, enumerable: !1, configurable: !1, writable: !1 })), !e.length) return t; let r, s; for (; r = e.shift();)(s = t) && !(t = t.get(r)) && (t = new ye, s.set(r, t)); return t } var ye = class extends Map { }; function oe(n, e, t = !1) { if (e == "") return n; var r = t ? n.lastIndexOf(e) : n.indexOf(e); return r === -1 ? "" : n.substr(r + e.length) } function we(n, e, t = !1) { if (e == "") return n; var r = t ? n.lastIndexOf(e) : n.indexOf(e); return r === -1 ? n : n.substr(0, r) } var J = class extends URLSearchParams { static eval(e, t, r = "&") { return t = t || "", (t.startsWith("?") ? t.substr(1) : t).split(r).filter(s => s).map(s => s.split("=").map(o => o.trim())).forEach(s => this.set(e, s[0], decodeURIComponent(s[1]))), e } static stringify(e, t = "&") { let r = []; return Object.keys(e).forEach(s => { this.reduceValue(e[s], s, (o, a, f = void 0) => { if (f) return f; r.push(`${a}=${encodeURIComponent(o)}`) }) }), r.join(t) } static get(e, t) { return this.reducePath(t, e, (r, s) => { if (!(!s && s !== 0)) return s[r] }) } static set(e, t, r) { this.reducePath(t, e, function (s, o, a = void 0) { let f = r; return a && (f = a), s === "" && Array.isArray(o) ? o.push(f) : o[s] = f, f }) } static reduceValue(e, t, r) { if (g(e)) { let s = Object.keys(e), o = r(e, t, s); if (Array.isArray(o)) return o.forEach(a => { this.reduceValue(e[a], t ? `${t}[${a}]` : a, r) }) } r(e, t) } static reducePath(e, t, r) { if (U(e) && e.endsWith("]") && g(t)) { let [s, ...o] = e.split("["); $(s) && (s = parseInt(s)), o = o.join("[").replace("]", ""); let a; if (s in t) a = t[s]; else { let f = o === "" || $(o.split("[")[0]) ? [] : {}; a = r(s, t, f) } return this.reducePath(o, a, r) } return $(e) && (e = parseInt(e)), r(e, t) } }; var V = class n extends FormData { static upgradeInPlace(e) { return e instanceof n ? e : Object.setPrototypeOf(e, n.prototype) } static json(e = {}, { recursive: t = !0, getIsJsonfiable: r = !1 } = {}) { let s = new n, o = !0; return J.reduceValue(e, "", (a, f, i = void 0) => { if (i) { let u = be(a) === "json"; return o = o && u, u && i } t && [!0, !1, null].includes(a) && (a = new Blob([a + ""], { type: "application/json" })), s.append(f, a) }), r ? [s, o] : s } async json({ recursive: e = !0, getIsJsonfiable: t = !1 } = {}) { let r = !0, s; for (let [o, a] of this.entries()) { s || (s = $(we(o, "[")) ? [] : {}); let f = be(a); if (e && ["Blob", "File"].includes(f) && a.type === "application/json") { let i = await a.text(); a = JSON.parse(i), f = "json" } r = r && f === "json", J.set(s, o, a) } return t ? [s, r] : s } }; var K = (n, ...e) => D(n, "fetch+", ...e), M = (n, ...e) => D(n, "fetch+", "meta", ...e); function _e(n) { return class extends n { static from(e) { let t = e.headers instanceof Headers ? [...e.headers.entries()].reduce((o, [a, f]) => { let i = a.toLowerCase(); return o[i] = o[i] ? [].concat(o[i], f) : f, o }, {}) : Object.keys(e.headers || {}).reduce((o, a) => (o[a.toLowerCase()] = e.headers[a], o), {}), r = e.body, s = be(r); if (["Blob", "File"].includes(s)) t["content-type"] ??= r.type, t["content-length"] ??= r.size; else if (["Uint8Array", "Uint16Array", "Uint32Array", "ArrayBuffer"].includes(s)) t["content-length"] ??= r.byteLength; else if (s === "json" && g(r)) { let [o, a] = V.json(r, { recursive: !0, getIsJsonfiable: !0 }); a ? (r = JSON.stringify(r, (f, i) => i instanceof Error ? { ...i, message: i.message } : i), t["content-type"] = "application/json", t["content-length"] = new Blob([r]).size) : (r = o, s = "FormData") } else s === "json" && !t["content-length"] && (t["content-length"] = (r + "").length); return { body: r, headers: t, $type: s } } async parse({ to: e = null, memoize: t = !1 } = {}) { let r = M(this, "cache"), s = ["text", "arrayBuffer", "blob", "bytes"].includes(e), o = (this.headers.get("Content-Type") || "").split(";")[0].trim(), a, f = () => { throw new Error(`Can't convert response of type ${o} to: ${e}`) }; if (!s && ["multipart/form-data", "application/x-www-form-urlencoded"].includes(o)) { if (e && !["formData", "json"].includes(e) && f(), t && r.has(e || "formData")) return r.get(e || "formData"); let i = await this.formData(); i && (i = V.upgradeInPlace(i), t && r.set("formData", i), e === "json" && (i = await i.json({ recursive: !0 }), t && r.set("json", { ...i }))), a = i } else if (!s && o === "application/json") { if (e && !["json", "formData"].includes(e) && f(), t && r.has(e || "json")) return r.get(e || "json"); let i = await this.json(); i && (t && r.set("json", { ...i }), e === "formData" && (i = V.json(i, { recursive: !0 }), t && r.set("formData", i))), a = i } else { if (e && !s && f(), t) { let i = r.get(e || "text") || r.get("original"); if (i) return i } a = await this[e || "text"](), t && r.set(e || "text", a) } return a } } } function be(n) { if (n instanceof FormData) return "FormData"; if (n === null || se(n) || ge(n)) return "json"; if (U(n) || g(n) && "toString" in n) return "text"; if (!g(n)) return null; let e = n[Symbol.toStringTag], t = ["Uint8Array", "Uint16Array", "Uint32Array", "ArrayBuffer", "Blob", "File", "FormData", "Stream", "ReadableStream"].reduce((r, s) => r || (e === s ? s : null), null); return t || (b(n) || Array.isArray(n) ? "json" : null) } function xt(n) { return n !== null && typeof n == "object" && typeof n.read == "function" && typeof n.pipe == "function" && typeof n.on == "function" } function De(n) { return n instanceof ReadableStream || xt(n) } function L(n, e = !0) { return C(n) ? n : !e && b(n) ? [n] : n !== !1 && n !== 0 && Ie(n) ? [] : Ce(n) ? Array.prototype.slice.call(n) : b(n) ? Object.values(n) : [n] } var T = class n extends upgradeMixin(Headers) { static upgradeInPlace(e) { return e instanceof n ? e : Object.setPrototypeOf(e, n.prototype) } set(e, t) { if (/^Set-Cookie$/i.test(e) && b(t) && (t = $e(t)), /Cookie/i.test(e) && g(t) && (t = [].concat(t).map($e).join(";")), /^Content-Range$/i.test(e) && Array.isArray(t)) { if (t.length < 2 || !t[0].includes("-")) throw new Error("A Content-Range array must be in the format: [ 'start-end', 'total' ]"); t = `bytes ${t.join("/")}` } if (/^Range$/i.test(e)) { let r = []; L(t).forEach((s, o) => { let a = Array.isArray(s) ? s.join("-") : s + ""; o === 0 && !a.includes("bytes=") && (a = `bytes=${a}`), r.push(a) }), t = r.join(", ") } return /^Accept$/i.test(e) && Array.isArray(t) && (t = t.join(",")), super.set(e, t) } append(e, t) { return /^Set-Cookie$/i.test(e) && b(t) && (t = $e(t)), super.append(e, t) } get(e, t = !1) { let r = super.get(e); if (/^Set-Cookie$/i.test(e) && t && (r = this.getSetCookie().map(s => { let [o, a] = s.split(";"), [f, i] = o.split("=").map(c => c.trim()), u = { name: f, value: i }; return a && a.split(/\;/g).map(c => c.trim().split("=")).forEach(c => { u[c[0][0].toLowerCase() + c[0].substring(1).replace("-", "")] = c.length === 1 ? !0 : c[1] }), u })), /^Cookie$/i.test(e) && t && (r = r?.split(";").map(s => { let [o, a] = s.split("=").map(f => f.trim()); return { name: o, value: a } }) || []), /^Content-Range$/i.test(e) && r && t && (r = oe(r, "bytes ").split("/")), /^Range$/i.test(e) && t && (r = r ? oe(r, "bytes=").split(",").map(s => { let o = s.trim().split("-").map(a => a ? parseInt(a, 10) : null); return o.render = a => (o[1] === null && (o[1] = a - 1), o[0] === null && (o[0] = o[1] ? a - o[1] - 1 : 0), o), o.isValid = (a, f) => !(o[0] > o[1] || o[1] < o[0] || o[0] < a || o[1] > f), o }) : []), /^Accept$/i.test(e) && r && t) { let s = f => { let [i, u] = f.trim().split(";").map(c => c.trim()); return [i, parseFloat((u || "q=1").replace("q=", ""))] }, o = r.split(",").map(f => s(f)).sort((f, i) => f[1] > i[1] ? -1 : 1) || [], a = r; r = { match(f) { if (!f) return 0; let i = c => c.split("/").map(l => l.trim()), u = i(f + ""); return o.reduce((c, [l, d]) => { if (c) return c; let h = i(l); return [0, 1].every(p => u[p] === h[p] || u[p] === "*" || h[p] === "*") ? d : 0 }, 0) }, toString() { return a } } } return r } }; function $e(n) { let e = [`${n.name}=${n.value}`]; for (let t in n) { if (["name", "value"].includes(t)) continue; let r = t[0].toUpperCase() + t.substring(1); r === "MaxAge" && (r = "Max-Age"), e.push(n[t] === !0 ? r : `${r}=${n[t]}`) } return e.join("; ") } var N = class n extends _e(Response) { constructor(e, t = {}) { super(e, t), T.upgradeInPlace(this.headers) } static upgradeInPlace(e) { return e instanceof n || (Object.setPrototypeOf(e, n.prototype), T.upgradeInPlace(e.headers)), e } static from(e, { memoize: t = !1, ...r } = {}) { if (e instanceof Response) return e; let s, o = e; if (e || e === 0) { let f; ({ body: e, headers: f, $type: s } = super.from({ body: e, headers: r.headers })), r = { ...r, headers: f } } let a = new this.constructor(e, r); if (t) { let f = M(a, "cache"), i = { json: "json", FormData: "formData", text: "text", ArrayBuffer: "arrayBuffer", Blob: "blob", Bytes: "bytes" }; f.set(i[s] || "original", e) } return a } get status() { return M(this).get("status") ?? super.status } clone() { let e = super.clone(); n.upgradeInPlace(e); let t = M(this); return K(e).set("meta", new Map(t)), t.has("cache") && t.set("cache", new Map(t.get("cache"))), e } }; async function nt(n, e = {}) { let t = await fetch(n, e); return N.upgradeInPlace(t), t } var xe = class n extends _e(Request) { constructor(e, t = {}) { super(e, t), T.upgradeInPlace(this.headers) } static upgradeInPlace(e) { return e instanceof n || (Object.setPrototypeOf(e, n.prototype), T.upgradeInPlace(e.headers)), e } static from(e, { memoize: t = !1, ...r } = {}) { if (e instanceof Request) return e; let s, o = r.body; if ("body" in r) { let { body: f, headers: i, $type: u } = super.from(r); r = { ...r, body: f, headers: i }, s = u } let a = new this.constructor(e, r); if (t) { let f = M(a, "cache"), i = { json: "json", FormData: "formData", text: "text", ArrayBuffer: "arrayBuffer", Blob: "blob", Bytes: "bytes" }; f.set(i[s] || "original", o) } return a } static async copy(e, t = {}) { let s = ["method", "headers", "mode", "credentials", "cache", "redirect", "referrer", "integrity"].reduce((o, a) => ({ ...o, [a]: a in t ? t[a] : a === "headers" ? new Headers(e[a]) : e[a] }), {}); return ["GET", "HEAD"].includes(t.method?.toUpperCase() || e.method) || ("body" in t ? (s.body = t.body, "headers" in t || (s.headers.delete("Content-Type"), s.headers.delete("Content-Length"))) : s.body = await e.clone().arrayBuffer()), s.mode === "navigate" && (s.mode = "cors"), { url: e.url, ...s } } clone() { let e = super.clone(); n.upgradeInPlace(e); let t = M(this); return K(e).set("meta", new Map(t)), t.has("cache") && t.set("cache", new Map(t.get("cache"))), e } }; var A = class extends MessageEvent { #t; get originalTarget() { return this.#t } #s; get eventID() { return this.#s } #n; get data() { return this.#n } #i; get live() { return this.#i } #u; get bubbles() { return this.#u } #c; get forwarded() { return this.#c } #a; get honourDoneMutationFlags() { return this.#a } #e = []; get ports() { return this.#e } constructor(e, { originalTarget: t = null, type: r = "message", eventID: s, live: o = !1, honourDoneMutationFlags: a = !1, bubbles: f = !1, forwarded: i = !1, ports: u = [] } = {}) { if (r && typeof r != "string") throw new TypeError("Where specified, wqEventOptions.type must be a string"); super(r), this.#n = e, this.#t = t, this.#s = s, this.#i = o, this.#u = f, this.#c = i, this.#a = a, this.#e = u; let c = this.#t && q(this.#t) || {}; if (this.#e.forEach(l => O.upgradeInPlace(l, { autoStart: c.autoStart, postAwaitsOpen: c.postAwaitsOpen })), g(this.#n) && this.#i) { if (typeof s != "string") throw new TypeError("eventID must be a non-empty string"); Le.call(t, this.#n, this.#s, { honourDoneMutationFlags: this.#a }) } } #o = !1; get immediatePropagationStopped() { return this.#o } stopImmediatePropagation() { this.#o = !0, this.#f = !0, super.stopImmediatePropagation() } #f = !1; get propagationStopped() { return this.#f } stopPropagation() { this.#f = !0, super.stopPropagation() } #r = !1; get defaultPrevented() { return this.#r } preventDefault() { this.#r = !0, super.preventDefault() } respondWith(e, t = []) { for (let r of this.#e) r.postMessage(e, t); return !!this.#e.length } }; var Qe = {}; Te(Qe, { any: () => $t, apply: () => Ue, batch: () => Ke, construct: () => He, defineProperties: () => Bt, defineProperty: () => le, deleteProperties: () => Nt, deleteProperty: () => pe, get: () => H, getOwnPropertyDescriptor: () => Pe, getOwnPropertyDescriptors: () => qt, getPrototypeOf: () => Ne, has: () => Ee, intercept: () => Lt, isExtensible: () => ke, map: () => Ft, observe: () => Je, ownKeys: () => We, path: () => Dt, preventExtensions: () => ze, reduce: () => Ge, set: () => X, setPrototypeOf: () => Ve, subtree: () => Rt }); var v = (n, ...e) => D(n, "observerAPI", ...e), ie = (n, e) => n instanceof Promise ? n.then(e) : e(n), ve = {}; var Q = class { constructor(e, t) { this.registry = e, Object.assign(this, { ...t, target: e.target }), this.params.signal && this.params.signal.addEventListener("abort", () => this.remove()) } remove() { return this.removed = !0, this.registry.removeRegistration(this) } }; var fe = class extends Q { constructor() { super(...arguments), this.emit.currentRegistration = this, Object.defineProperty(this, "abortController", { value: new AbortController }), Object.defineProperty(this, "signal", { value: this.abortController.signal }), ve.setMaxListeners?.(0, this.signal) } remove() { this.abortController.abort(), super.remove() } fire(e) { if (this.emit.recursionTarget && !["inject", "force-async", "force-sync"].includes(this.params.recursions)) return; let t = e, r = this.filter; if (r !== 1 / 0 && (r = L(r, !1)) && (t = e.filter(o => r.includes(o.key))), this.params.diff && (t = t.filter(o => o.type !== "set" || o.value !== o.oldValue)), !t.length) return; if (["inject", "defer"].includes(this.params.recursions)) { if (this.emit.recursionTarget) { this.emit.recursionTarget.push(...t); return } this.emit.recursionTarget = this.params.recursions === "inject" ? t : [] } let s = this.filter === 1 / 0 || Array.isArray(this.filter) ? this.emit(t, this) : this.emit(t[0], this); return ie(s, o => { let a = this.emit.recursionTarget; return delete this.emit.recursionTarget, this.params.recursions === "defer" && a?.length ? this.emit.currentRegistration.fire(a) : o }) } }; var Z = class { constructor(e) { this.target = e, this.entries = [] } addRegistration(e) { return this.entries.push(e), e } removeRegistration(e) { this.entries = this.entries.filter(t => t !== e) } static _getInstance(e, t, r = !0, s = this.__namespace) { if (!g(t)) throw new Error(`Subject must be of type object; "${re(t)}" given!`); let o = this; return s && v(globalThis, "observerAPI", "namespaces").has(e + "-" + s) && (o = v(globalThis, "observerAPI", "namespaces").get(e + "-" + s), e += "-" + s), !v(t, "registry").has(e) && r && v(t, "registry").set(e, new o(t)), v(t, "registry").get(e) } static _namespace(e, t, r = null) { if (e += "-" + t, arguments.length === 2) return v(globalThis, "observerAPI", "namespaces").get(e); if (!(r.prototype instanceof this)) throw new Error(`The implementation of the namespace ${this.name}.${t} must be a subclass of ${this.name}.`); v(globalThis, "observerAPI", "namespaces").set(e, r), r.__namespace = t } }; var P = class { constructor(e, t) { if (this.target = e, !t.operation) throw new Error("Descriptor operation must be given in definition!"); Object.assign(this, t) } }; var k = class extends Z { static getInstance(e, t = !0, r = null) { return super._getInstance("listeners", ...arguments) } static namespace(e, t = null) { return super._namespace("listeners", ...arguments) } constructor(e) { super(e), this.batches = [] } addRegistration(e, t, r) { return super.addRegistration(new fe(this, { filter: e, emit: t, params: r })) } emit(e, { eventsArePropertyDescriptors: t = !1, eventIsArrayMethodDescriptor: r = !1 } = {}) { if (this.batches.length) { let s = this.batches[0].params.arrayMethodName; this.batches[0].snapshots.push({ events: [...e], arrayMethodName: s, eventsArePropertyDescriptors: t, eventIsArrayMethodDescriptor: r }); return } this.$emit(this.entries, [{ events: e, eventsArePropertyDescriptors: t, eventIsArrayMethodDescriptor: r }]) } $emit(e, t) { let r = 0, s = 0, o = 0; for (let c of e) r += 1, c.params.withPropertyDescriptors && (s += 1), c.params.withArrayMethodDescriptors && (o += 1); let a = [], f = [], i = [], u = []; for (let c of t) { let l = c.arrayMethodName, d = c.eventsArePropertyDescriptors, h = c.eventIsArrayMethodDescriptor; for (let p of c.events) if (l && (p.operation = l), s && (o && a.push(p), h || o !== r && f.push(p)), s !== r) { let m = p; if (d) { let { target: w, type: x, ..._ } = p; m = new P(w, { type: "set", ..._ }), Object.defineProperty(m, "value", "get" in _.value ? { get: () => _.value.get() } : { value: _.value.value }), _.oldValue && Object.defineProperty(m, "oldValue", "get" in _.oldValue ? { get: () => _.oldValue.get() } : { value: _.oldValue.value }) } o && i.push(m), h || o !== r && u.push(m) } } for (let c of e) c.params.withPropertyDescriptors ? c.params.withArrayMethodDescriptors ? a.length && c.fire(a) : f.length && c.fire(f) : c.params.withArrayMethodDescriptors ? i.length && c.fire(i) : u.length && c.fire(u) } batch(e, t = {}) { this.batches.unshift({ entries: [...this.entries], snapshots: [], params: t }); let r = e(); return ie(r, s => { let o = this.batches.shift(); return o.snapshots.length && this.$emit(o.entries, o.snapshots), s }) } }; var ue = class extends Q { exec(e, t, r) { return this.running || !this.traps[e.operation] ? t(...Array.prototype.slice.call(arguments, 2)) : (this.running = !0, this.traps[e.operation](e, r, (...s) => (this.running = !1, t(...s)))) } }; var W = class extends Z { static getInstance(e, t = !0, r = null) { return super._getInstance("traps", ...arguments) } static namespace(e, t = null) { return super._namespace("traps", ...arguments) } addRegistration(e) { return super.addRegistration(new ue(this, e)) } emit(e, t = null) { let r = this; return function s(o, ...a) { let f = r.entries[o]; return f ? f.exec(e, (...i) => s(o + 1, ...i), ...a) : t ? t(e, ...a) : a[0] }(0) } }; var Be = {}; Te(Be, { accessorize: () => It, proxy: () => qe, unaccessorize: () => Ct, unproxy: () => ce }); var st = Symbol("wqOriginal"); function It(n, e, t = {}) { n = Fe(n); let r = v(n, "accessorizedProps"); function s(i) { let u, c = n; do u = Object.getOwnPropertyDescriptor(c, i); while (!u && (c = Object.getPrototypeOf(c))); return u ? { proto: c, descriptor: u } : { descriptor: { value: void 0, configurable: !0, enumerable: !0, writable: !0 } } } function o(i) { if (r.has(i + "")) return !0; let u = s(i); u.getValue = function (d = !1) { return d ? this.descriptor : this.descriptor.get ? this.descriptor.get() : this.descriptor.value }, u.setValue = function (d, h = !1) { if (this.dirty = !0, h) { this.descriptor = d; return } return this.descriptor.set ? this.descriptor.set(d) !== !1 : (this.descriptor.value = d, !0) }, u.intact = function () { let d = Object.getOwnPropertyDescriptor(n, i); return d?.get === l.get && d?.set === l.set && r.get(i + "") === this }, u.restore = function () { return this.intact() ? (this.proto && this.proto !== n || !this.proto && !this.dirty ? delete n[i] : Object.defineProperty(n, i, this.descriptor), r.delete(i + ""), !0) : !1 }, r.set(isNaN(i) ? i : parseInt(i), u); let { enumerable: c = !0 } = u.descriptor, l = { enumerable: c, configurable: !0 }; ("value" in u.descriptor || u.descriptor.set) && (l.set = function (d) { return X(this, i, d, t) }), ("value" in u.descriptor || u.descriptor.get) && (l.get = function () { return H(this, i, t) }); try { return Object.defineProperty(n, i, l), !0 } catch { return r.delete(i + ""), !1 } } let f = (Array.isArray(e) ? e : e === void 0 ? Object.keys(n) : [e]).map(o); return e === void 0 || Array.isArray(e) ? f : f[0] } function Ct(n, e, t = {}) { n = Fe(n); let r = v(n, "accessorizedProps"); function s(f) { return r.has(f + "") ? r.get(f + "").restore() : !0 } let a = (Array.isArray(e) ? e : e === void 0 ? Object.keys(n) : [e]).map(s); return e === void 0 || Array.isArray(e) ? a : a[0] } function qe(n, e = {}, t = void 0) { let r = Fe(n); if (typeof e.membrane == "boolean") throw new Error("The params.membrane parameter cannot be of type boolean."); if (e.membrane && v(r, "membraneRef").has(e.membrane)) return v(r, "membraneRef").get(e.membrane); let s = { apply: (f, i, u) => Ue(f, i, u, void 0, e), construct: (f, i, u = null) => He(f, i, u, e), defineProperty: (f, i, u) => le(f, i, u, e), deleteProperty: (f, i) => pe(f, i, e), get: (f, i, u = null) => { if (i === st) return r; let c = { ...e, receiver: u }, l = H(f, i, c); return Array.isArray(f) && typeof l == "function" && !/^class\s?/.test(Function.prototype.toString.call(l)) ? qe(l, { ...e, arrayMethodName: i, membrane: u }, t) : e.chainable && g(l) && i !== "prototype" && !(typeof l == "function" && /^class\s?|\{\s\[native\scode\]\s\}$/.test(Function.prototype.toString.call(l))) ? qe(l, e, t) : l }, getOwnPropertyDescriptor: (f, i) => Pe(f, i, e), getPrototypeOf: f => Ne(f, e), has: (f, i) => Ee(f, i, e), isExtensible: f => ke(f, e), ownKeys: f => We(f, e), preventExtensions: f => ze(f, e), set: (f, i, u, c = null) => X(f, i, u, { ...e, receiver: c }), setPrototypeOf: (f, i) => Ve(f, i, e) }, o = t?.(s) || s, a = new Proxy(r, o); return e.membrane && v(r, "membraneRef").set(e.membrane, a), a } function ce(n) { return n && n[st] || n } function Fe(n) { if (!n || !g(n)) throw new Error("Target must be of type object!"); return ce(n) } var de = class extends Array { }; function Dt(...n) { return new de(...n) } var Y = class extends Array { }; function Rt() { return new Y } function $t() { return 1 / 0 } function Ge(n, e, t, r = o => o, s = {}) { let o = e instanceof Y; if (!(!o && !e?.length)) return function a(f, i, u, c) { let l = c || i[u.level] instanceof Y, d = l ? 1 / 0 : i[u.level], h = l ? !1 : u.level === i.length - 1; return f instanceof P && f.operation !== "get" ? u = { ...u, probe: "always" } : u.probe !== "always" && (u = { ...u, probe: !h }), t(f, d, (p, ...m) => { let w = y => { y instanceof P && (y.path = "key" in y ? [y.key] : [], f instanceof P && (y.path = "key" in y ? f.path.concat(y.key) : f.path.slice(0), Object.defineProperty(y, "context", { get: () => f, configurable: !0 }))) }, x = m[0] || {}, _ = y => { if (y instanceof P && "argumentsList" in y) return; let I = F(y, !1); return ie(I, S => (y instanceof P ? y.value = S : y = S, a(y, i, { ...u, ...x, keyInParent: y.key, level: u.level + 1 }, l))) }; if (he(d) && Array.isArray(p)) { if (p.forEach(w), h) return r(p, ...m); l && p[0] instanceof P && (p[0].operation !== "get" || s.asGet) && r(p, ...m); for (let y of p) _(y); return } return w(p), h ? r(p, ...m) : _(p) }, u) }(n, e.slice(0), { ...s, level: 0 }, o) } function Je(n, e, t, r = {}) { let s = F(n, !r.level); if (B(arguments[1]) && ([, t, r = {}] = arguments, e = 1 / 0), !B(t)) throw new Error(`Handler must be a function; "${re(t)}" given!`); if (e instanceof de || e instanceof Y) return Ge(s, e, Je, t, r); if (r = { ...r, descripted: !0 }, delete r.live, !g(s)) return r.probe && H(s, e, t, r) || void 0; let o = ot(s, e, t, r); return r.probe ? H(s, e, o, r) : o() } function Lt(n, e, t = {}) { let r = F(n); return b(e) || ([, , , t = {}] = arguments, e = { [arguments[1]]: arguments[2] }), W.getInstance(r, !0, t.namespace).addRegistration({ traps: e, params: t }) } function Pe(n, e, t = s => s, r = {}) { return R(n, "getOwnPropertyDescriptor", { key: e }, t, r) } function qt(n, e, t = s => s, r = {}) { return R(n, "getOwnPropertyDescriptors", { key: e }, t, r) } function Ne(n, e = r => r, t = {}) { return R(n, "getPrototypeOf", {}, e, t) } function ke(n, e = r => r, t = {}) { return R(n, "isExtensible", {}, e, t) } function We(n, e = r => r, t = {}) { return R(n, "ownKeys", {}, e, t) } function Ee(n, e, t = s => s, r = {}) { return R(n, "has", { key: e }, t, r) } function H(n, e, t = s => s, r = {}) { let s, o = F(n, !r.level); return b(t) ? [r, t] = [t, a => a] : r.live && (s = !0), e instanceof de || e instanceof Y ? Ge(o, e, H, t, { ...r, asGet: !0 }) : kt(o, e, a => { let f = [...a]; return function i(u, c, l) { if (!c.length) return l(u); let d = c.shift(); if (!["string", "number", "symbol"].includes(typeof d)) throw new Error(`Property name/key ${d} invalid.`); function h(w, x = void 0) { let _ = S => (w.value = S, i([...u, r.live || r.descripted ? w : S], c, l)); if (arguments.length > 1) return _(x); if (!g(o)) return _(o?.[w.key]); let y = v(o, "accessorizedProps", !1), I = y && y.get(w.key); if (I && I.intact()) return _(I.getValue(r.withPropertyDescriptors)); if (r.withPropertyDescriptors) { let S = Object.getOwnPropertyDescriptor(o, w.key); return _(S) } return _(Reflect.get(o, w.key)) } let p = new P(o, { type: "get", key: d, value: void 0, operation: "get", related: f }); if (!g(o)) return h(p); let m = W.getInstance(o, !1, r.namespace); return m ? m.emit(p, h) : h(p) }([], a.slice(0), i => { let u = he(e) ? i : i[0]; return s && g(o) ? ot(o, e, t, r, n.key)(u) : t(u) }) }, r) } function Ke(n, e, t = {}) { let r = F(n); return k.getInstance(r, !0, t.namespace).batch(e, t) } function Ft(n, e, t = {}) { e = F(e), n = F(n); let r = (t.only || []).slice(0), s = (t.except || []).slice(0), o = Object.keys(t.spread ? [...n] : n).map(u => isNaN(u) ? u : parseInt(u)), a = r.length ? r.filter(u => o.includes(u)) : o.filter(u => !s.includes(u)), f = u => !Array.isArray(e) || isNaN(u) ? u : u - s.filter(c => c < u).length, i = u => { let c = Pe(n, u, t); "value" in c && c.writable && c.enumerable && c.configurable ? X(e, f(u), c.value, t) : (c.enumerable || t.onlyEnumerable === !1) && le(e, u, { ...c, configurable: !0 }, t) }; return Ke(e, () => { a.forEach(i) }), Je(n, u => { u.filter(c => r.length ? r.includes(c.key) : !s.includes(c.key)).forEach(c => { if (c.type === "delete") return pe(e, f(c.key), t); if (c.type === "def") { (c.value.enumerable || t.onlyEnumerable === !1) && le(e, f(c.key), { ...c.value, configurable: !0 }, t); return } i(c.key) }) }, { ...t, withPropertyDescriptors: !0 }) } function X(n, e, t, r = a => a, s = {}, o = !1) { let a = F(n), f = [[e, t]]; b(e) && ([, , r = u => u, s = {}, o = !1] = arguments, f = Object.entries(e)), b(r) && ([o, s, r] = [typeof s == "boolean" ? s : o, r, u => u]); let i = f.map(([u]) => u); return function u(c, l, d) { if (!l.length) return d(c); let [h, p] = l.shift(); function m(x, _ = void 0) { let y = pt => (x.status = pt, u(c.concat(x), l, d)); if (arguments.length > 1) return y(x, _); let I = v(a, "accessorizedProps", !1), S = I && I.get(x.key); return x.type === "def" ? (S && !S.restore() && y(!1), Object.defineProperty(a, x.key, x.value), y(!0)) : S && S.intact() ? y(S.setValue(x.value)) : y(Reflect.set(a, x.key, x.value)) } function w(x, _) { if (s.diff && p === _) return u(c, l, d); let y = new P(a, { type: o ? "def" : "set", key: h, value: p, isUpdate: x, oldValue: _, related: [...i], operation: o ? "defineProperty" : "set", detail: s.detail }), I = W.getInstance(a, !1, s.namespace); return I ? I.emit(y, m) : m(y) } return Ee(a, h, x => { if (!x) return w(x); if (h === "length" && Array.isArray(a) && v(a).has("$length")) return w(!0, v(a).get("$length")); let _ = { ...s, withPropertyDescriptors: o }; return H(a, h, y => w(x, y), _) }, s) }([], f.slice(0), u => { let c = k.getInstance(a, !1, s.namespace); return c && c.emit(u, { eventsArePropertyDescriptors: !!o }), r(he(e) ? u.map(l => l.status) : u[0]?.status) }) } function le(n, e, t, r = o => o, s = {}) { return X(n, e, t, r, s, !0) } function Bt(n, e, t = s => s, r = {}) { return X(n, e, t, r, !0) } function pe(n, e, t = s => s, r = {}) { let s = F(n); b(t) && ([r, t] = [t, f => f]); let o = L(e, !1), a = [...o]; return function f(i, u, c) { if (!u.length) return c(i); let l = u.shift(); function d(p, m = void 0) { let w = y => (p.status = y, f(i.concat(p), u, c)); if (arguments.length > 1) return w(p, m); let x = v(s, "accessorizedProps", !1), _ = x && x.get(p.key); return _ && !_.restore() && w(!1), w(Reflect.deleteProperty(s, p.key)) } function h(p) { let m = new P(s, { type: "delete", key: l, oldValue: p, related: [...a], operation: "deleteProperty", detail: r.detail }), w = W.getInstance(s, !1, r.namespace); return w ? w.emit(m, d) : d(m) } return H(s, l, h, r) }([], o.slice(0), f => { let i = k.getInstance(s, !1, r.namespace); return i && i.emit(f), t(he(e) ? f.map(u => u.status) : f[0].status) }) } function Nt(n, e, t = s => s, r = {}) { return pe(...arguments) } function He(n, e, t = null, r = o => o, s = {}) { return R(n, "construct", arguments.length > 2 ? { argumentsList: e, newTarget: t } : { argumentsList: e }, r, s) } function Ue(n, e, t, r = o => o, s = {}) { let o = ce(e), a; if (Array.isArray(e)) { if (s.arrayMethodName) { let f = new P(o, { operation: s.arrayMethodName, argumentsList: t }); k.getInstance(o, !1, s.namespace)?.emit([f], { eventIsArrayMethodDescriptor: !0 }) } v(o).set("$length", o.length), a = Ke(o, () => R(n, "apply", { thisArgument: e, argumentsList: t }, r, s), s), v(o).delete("$length") } else a = R(n, "apply", { thisArgument: o, argumentsList: t }, r, s); return a } function Ve(n, e, t = s => s, r = {}) { return R(n, "setPrototypeOf", { proto: e }, t, r) } function ze(n, e = r => r, t = {}) { return R(n, "preventExtensions", {}, e, t) } function ot(n, e, t, r = {}) { let s = new AbortController; ve.setMaxListeners?.(0, s.signal), r.signal && r.signal.addEventListener("abort", () => s.abort()); let o = { ...r, signal: s.signal }, a = k.getInstance(n, !0, o.namespace), f = new Map; return function i(u = [], c = null) { let l, d, h; if (he(e)) { if (c) { h = !0, d = c; for (let p of u) f.get(p.key)?.remove(), f.delete(p.key) } else d = a.addRegistration(e, i, o); l = { signal: d.signal, childRegistrations: f } } else c?.remove(), d = a.addRegistration(e, i, o), l = { signal: d.signal }; if (o.childRegistrations && o.keyInParent && o.childRegistrations.set(o.keyInParent, d), arguments.length) { let p = t(u, l); if (arguments.length > 1) return p } return s } } function R(n, e, t = {}, r = o => o, s = {}) { n = F(n), b(r) && ([s, r] = [r, i => i]); function o(i, u) { return arguments.length > 1 ? r(u) : r((Reflect[e] || Object[e])(n, ...Object.values(t))) } let a = new P(n, { operation: e, ...t }), f = W.getInstance(n, !1, s.namespace); return f ? f.emit(a, o) : o(a) } function he(n) { return n === 1 / 0 || Array.isArray(n) } function F(n, e = !0, t = !0) { if ((!n || !g(n)) && e) throw new Error(`Object must be of type object or array! "${re(n)}" given.`); return n instanceof P && (n.type === "def" && t ? n = typeof n.value.get == "function" ? n.value.get() : n.value.value : n = n.value), n && ce(n) } function kt(n, e, t, r = {}) { return e === 1 / 0 ? r.level && !g(n) ? t([]) : t(Object.entries(Object.getOwnPropertyDescriptors(n)).filter(([, s]) => s.writable !== !1 && !s.get && !s.set).map(([s]) => s)) : t(L(e, !1)) } var j = { ...Qe, ...Be }, z = j; var ee = class extends Oe(EventTarget) { #t; constructor(e, { autoStart: t = !0, naturalOpen: r = !0, postAwaitsOpen: s = !1 } = {}) { if (super(), this.#t = typeof e == "string" ? new WebSocket(e) : e, E(this).set("options", { autoStart: t, naturalOpen: r, postAwaitsOpen: s }), this.constructor.upgradeEvents(this.#t, this), r && t && this.#t.readyState === WebSocket.OPEN && this.start(), this.#t.readyState === WebSocket.CLOSED) try { this.close() } catch { } } static _hydrateMessage(e, t) { try { let r; if (typeof t.data == "string" && b(r = JSON.parse(t.data)) && r[".wq"]) return Object.defineProperty(t, "data", { value: r, configurable: !0 }), super._hydrateMessage(e, t) } catch { } return t } __postMessage(e, t) { this.#t.send(JSON.stringify(e), t) } }; var it = (n, ...e) => D(n, "port+", ...e), E = (n, ...e) => D(n, "port+", "meta", ...e), q = n => D(n, "port+", "meta").get("options") || {}, at = ["addEventListener", "addRequestListener", "postMessage", "postRequest", "dispatchEvent", "relay", "start", "readyStateChange", "removeEventListener", "close"], ft = ["options", "readyState", "onmessage", "onmessageerror"], O = class extends ut(EventTarget) { constructor(e = {}) { super(), it(this, "meta").set("options", e) } static [Symbol.hasInstance](e) { return Function.prototype[Symbol.hasInstance].call(this, e) ? !0 : at.every(t => typeof e[t] == "function") || ft.every(t => t in e) } }; function ut(n) { return class extends n { static upgradeInPlace(e, t = {}) { if (e instanceof O) return e; let r = this.prototype; for (let o of at) { let a = e[o], f = r[o]; a && Object.defineProperty(e, `_${o}`, { value: a.bind(e), configurable: !0 }), Object.defineProperty(e, o, { value: f.bind(e), configurable: !0 }) } for (let o of ft) { let a = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(e), o), f = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(r), o); a && Object.defineProperty(e, `_${o}`, { ...a, configurable: !0 }), Object.defineProperty(e, o, { ...f, configurable: !0 }) } return it(e, "meta").set("options", t), this.upgradeEvents(e), e } static upgradeEvents(e, t = null) { t || (t = e); let r = E(e); if (r.get("events+")) return; let s = E(t), o = q(t), a = te.call(t), f = ae.call(t); e instanceof BroadcastChannel && (o.clientServerMode === "server" ? s.set("clients", new Set) : o.clientServerMode === "client" && s.set("client_id", `client-${(0 | Math.random() * 9e6).toString(36)}`)); let i = l => { if (l instanceof A) return; if (e === t && l.stopImmediatePropagation?.(), l = this._hydrateMessage?.(t, l) || l, l.data.ping === "connect" && typeof l.data?.[".wq"]?.eventID == "string" && (!(e instanceof WebSocket) || !o.naturalOpen)) { let m = !0; e instanceof BroadcastChannel && (o.clientServerMode === "server" && typeof l.data.id == "string" ? (s.get("clients").add(l.data.id), m = "server") : l.data.id === "server" && s.has("client_id") && (m = s.get("client_id"))), l.ports?.forEach(w => w.postMessage(m)), s.set("remote.start.called", !0), t.start(); return } if (l.data.ping === "disconnect" && typeof l.data?.[".wq"]?.eventID == "string") { let m = () => { s.set("remote.close.called", !0), t.close() }; e instanceof BroadcastChannel ? o.clientServerMode === "server" && typeof l.data.id == "string" ? (s.get("clients").delete(l.data.id), !s.get("clients").size && o.autoClose && !f.close.state && m()) : o.clientServerMode === "client" && l.data.id === "server" && m() : e instanceof MessagePort && m(); return } let d = l.data, h = {}; typeof l.data?.[".wq"]?.eventID == "string" && ({ message: d, ".wq": h } = l.data); let p = new A(d, { originalTarget: e, ...h, ports: l.ports }); t.dispatchEvent(p) }, u = l => { e instanceof WebSocket && o.naturalOpen && !(l instanceof A) && (s.set("remote.start.called", !0), t.start()) }, c = l => { (e instanceof WebSocket || e instanceof MessagePort) && !(l instanceof A) && (s.set("remote.close.called", !0), t.close()) }; r.set("internal_call", !0), e.addEventListener("message", i), e.addEventListener("error", i), e.addEventListener("open", u), e.addEventListener("close", c), r.delete("internal_call"), r.set("events+", !0), a.add(() => { e.removeEventListener("message", i), e.removeEventListener("error", i), e.removeEventListener("open", u), e.removeEventListener("close", c), r.set("events+", !1) }) } get options() { return { ...q(this) } } get onmessageerror() { return typeof super.onmessageerror < "u" ? super.onmessageerror : typeof this._onmessageerror < "u" ? this._onmessageerror : null } set onmessageerror(e) { if (typeof super.onmessageerror < "u") { super.onmessageerror = e; return } if (e !== null && typeof e != "function") throw new TypeError("onmessageerror must be a function"); if (Object.getOwnPropertyDescriptor(this, "_onmessageerror")?.set) { this._onmessageerror = e; return } this._onmessageerror && this.removeEventListener("messageerror", this._onmessageerror), this.addEventListener("messageerror", e), this._onmessageerror = e } get onmessage() { return typeof super.onmessage < "u" ? super.onmessage : typeof this._onmessage < "u" ? this._onmessage : null } set onmessage(e) { let t = E(this), r = q(this); if (!t.get("internal_call") && r.autoStart && this.start(), typeof super.onmessage < "u") { super.onmessage = e; return } if (e !== null && typeof e != "function") throw new TypeError("onmessage must be a function"); if (Object.getOwnPropertyDescriptor(this, "_onmessage")?.set) { this._onmessage = e; return } this._onmessage && this.removeEventListener("message", this._onmessage), this.addEventListener("message", e), this._onmessage = e } addEventListener(...e) { let t = E(this), r = q(this); return !t.get("internal_call") && r.autoStart && this.start(), te.call(this).add(() => { this._removeEventListener ? this._removeEventListener(...e) : super.removeEventListener(...e) }), this._addEventListener ? this._addEventListener(...e) : super.addEventListener(...e) } dispatchEvent(e) { let t = this._dispatchEvent ? this._dispatchEvent(e) : super.dispatchEvent(e); return e instanceof A && Wt.call(this, e), t } postMessage(e, t = {}) { let r = E(this), s = q(this); !r.get("internal_call") && s.autoStart && this.start(); let o = ae.call(this); o.messaging.state = !0, o.messaging.resolve(); let a, { portOptions: f, wqOptions: { relayedFrom: i, ...u } } = Se.call(this, e, t); (u.type !== "message" || u.live || u.bubbles || f.transfer?.length && (this instanceof BroadcastChannel || this instanceof ee)) && (e = { message: e, ".wq": u }), t = f, a = i; let c = () => { this._postMessage ? this._postMessage(e, t, a) : super.postMessage(e, t) }; s.postAwaitsOpen ? o.open.promise.then(c) : c() } addRequestListener(e, t, r = {}) { let s = async o => { let a = await t(o); for (let f of o.ports) f.postMessage(a) }; this.addEventListener(e, s, r) } postRequest(e, t, r = {}) { let s; b(t) && (r = { once: !0, ...t }, s = new Promise(c => { t = c })); let o = new MessageChannel; this.constructor.upgradeEvents(o.port1), o.port1.start(); let { signal: a = null, once: f = !1, transfer: i = [], ...u } = r; return o.port1.addEventListener("message", c => t(c), { signal: a, once: f }), a?.addEventListener("abort", () => { o.port1.close(), o.port2.close() }), this.postMessage(e, { ...u, transfer: [o.port2].concat(i) }), s } relay({ to: e, from: t, types: r = "*", channel: s = null, resolveMessage: o = null, bidirectional: a = !1 } = {}) { if (e && t) throw new Error('Only one of "to" and "from" may be specified'); if (t ? e = this : t = this, e === t) throw new Error("Source and target ports cannot be the same"); if (!(t instanceof O) || !(e instanceof O)) throw new Error("Both source and target ports must be instance of MessagePortPlus."); if (typeof r != "function" && !(r = [].concat(r)).length) throw new Error("Event types must be specified."); if (typeof s == "string") s = { from: s }; else if (b(s)) { if (Object.keys(s).filter(c => !["from", "to"].includes(c)).length) throw new Error('Channel must be a string or an object of "from"/"to" members') } else if (s) throw new Error("Invalid channel parameter"); let f = ct.call(t), i = { targetPort: e, types: r, channel: s, resolveMessage: o }; f.add(i); let u; return a && (u = e.relay({ to: t, types: r, channel: s && { to: s.from, from: s.to }, resolveMessage: o, bidirectional: !1 })), () => { f.delete(i), u?.() } } channel(e, t = null) { let r = new MessageChannel; return O.upgradeInPlace(r.port1, { autoStart: this.options.autoStart, postAwaitsOpen: this.options.postAwaitsOpen }), O.upgradeInPlace(r.port2, { autoStart: this.options.autoStart, postAwaitsOpen: this.options.postAwaitsOpen }), te.call(this).add(this.relay({ channel: e, to: r.port1, bidirectional: !0, resolveMessage: t })), r.port1.start(), this.readyStateChange("close").then(() => { r.port1.close() }), r.port2 } projectMutations({ from: e, to: t, ...r }) { if (!e || !t || typeof e == "string" && typeof t == "string" || g(e) && g(t)) throw new Error('Invalid "from"/"to" parameters'); if (typeof e == "string") { if (!g(t)) throw new Error('Invalid "to" parameter. Object/array expected'); return Le.call(this, t, e, r) } if (typeof t == "string") { if (!g(e)) throw new Error('Invalid "from" parameter. Object/array expected'); return lt.call(this, e, t, r) } throw new Error('Invalid "from"/"to" parameters') } get readyState() { let e = ae.call(this); return e.close.state ? "closed" : e.open.state ? "open" : "connecting" } readyStateChange(e) { if (!["open", "messaging", "close"].includes(e)) throw new Error(`Invalid readyState query "${e}"`); return ae.call(this)[e].promise } start() { let e = ae.call(this); if (e.open.state) return; let t, r = () => { if (e.open.state) return; e.open.state = !0, e.open.resolve(); let u = new A(null, { type: "open" }); this._dispatchEvent ? this._dispatchEvent(u) : super.dispatchEvent(u), t?.port1.close(), t?.port2.close() }, s = E(this), o = q(this); if (s.get("remote.start.called")) { r(); return } if (s.get("start.called")) return; s.set("start.called", !0), this._start ? this._start() : super.start?.(), t = new MessageChannel, t.port1.onmessage = u => { this instanceof BroadcastChannel && o.clientServerMode === "server" && typeof u.data == "string" && s.get("clients").add(u.data), r() }; let { wqOptions: a } = Se.call(this), f = o.clientServerMode === "server" ? "server" : o.clientServerMode === "client" ? s.get("client_id") : null, i = { ".wq": a, ping: "connect", id: f }; this._postMessage ? this._postMessage(i, { transfer: [t.port2] }) : super.postMessage(i, { transfer: [t.port2] }) } close(...e) { let t = ae.call(this); if (t.close.state) return; t.close.state = !0; let r = E(this), s = q(this); if (!r.get("remote.close.called") && (this instanceof BroadcastChannel || this instanceof MessagePort)) { let { wqOptions: a } = Se.call(this), f = s.clientServerMode === "server" ? "server" : s.clientServerMode === "client" ? r.get("client_id") : null, i = { ".wq": a, ping: "disconnect", id: f }; this._postMessage ? this._postMessage(i) : super.postMessage(i) } this._close ? this._close(...e) : super.close(...e), t.close.resolve(); let o = new A(null, { type: "close" }); this._dispatchEvent ? this._dispatchEvent(o) : super.dispatchEvent(o), Ht.call(this) } } } function Oe(n) { return class extends ut(n) { static _hydrateMessage(e, t) { if (typeof t.data?.[".wq"]?.numPorts != "number" || typeof t.data[".wq"].eventID != "string") return t; let r = te.call(e), s = t.data[".wq"].numPorts; Object.defineProperty(t, "ports", { value: [], configurable: !0 }); for (let o = 0; o < s; o++) { let a = e.channel(`${t.data[".wq"].eventID}:${o}`); t.ports.push(a) } return t } _postMessage(e, t = {}) { let { transfer: r = [], ...s } = t; if (typeof e?.[".wq"]?.eventID == "string") { let o = te.call(this), a = r.filter(i => i instanceof MessagePort), f = a.length; for (let i = 0; i < f; i++)O.upgradeInPlace(a[i]), o.add(this.relay({ channel: `${e[".wq"].eventID}:${i}`, to: a[i], bidirectional: !0 })), a[i].start(), a[i].readyStateChange("close").then(() => { let { wqOptions: u } = Se.call(this), c = { ".wq": u, ping: "disconnect" }; this.postMessage(c, { type: `${e[".wq"].eventID}:${i}:message` }) }); e[".wq"].numPorts = f } return this.__postMessage(e, s) } } } function Wt(n) { if (n.propagationStopped) return; let e = E(this); e.get("parentNode") instanceof EventTarget && (n.bubbles || e.get("parentNode")?.findPort?.(r => r === this) && n instanceof A) && e.get("parentNode").dispatchEvent(n); let t = ct.call(this); if (t.size && n instanceof A) { let { type: r, eventID: s, data: o, live: a, bubbles: f, ports: i } = n, u = new WeakSet; for (let { targetPort: c, types: l, channel: d, resolveMessage: h } of t) { if (u.has(c)) continue; let p = r; d.from && ([, p] = new RegExp(`^${d.from.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}:([^:]+)$`).exec(r) || [], !p) || !(typeof l == "function" ? l(p, this, c, d) : [].concat(l).find(w => w === p || w === "*")) || (u.add(c), c.postMessage(h ? h(o, this, c, d) : o, { transfer: i, type: d.to ? `${d.to}:${p}` : p, eventID: s, bubbles: f, live: a, forwarded: !0, relayedFrom: this })) } } } function te() { let n = E(this); return n.has("garbage_collection") || n.set("garbage_collection", new Set), n.get("garbage_collection") } function ct() { let n = E(this); return n.has("downstream_registry") || n.set("downstream_registry", new Set), n.get("downstream_registry") } function ae() { let n = E(this); if (!n.has("readystate_registry")) { let e = t => (t.promise = new Promise((r, s) => (t.resolve = () => r(this), t.reject = s)), t); n.set("readystate_registry", { open: e({}), messaging: e({}), close: e({}) }) } return n.get("readystate_registry") } function Ht() { let n = E(this); for (let e of n.get("garbage_collection") || []) e instanceof AbortController ? e.abort() : typeof e == "function" && e(); n.get("garbage_collection")?.clear(), n.get("downstream_registry")?.clear() } function Se(n = void 0, e = {}) { if (Array.isArray(e)) e = { transfer: e }; else if (!e || typeof e != "object") throw new TypeError("transferOrOptions must be an array or an object"); let { type: t = "message", eventID: r = null, live: s = !1, observing: o = !1, bubbles: a = !1, forwarded: f = !1, relayedFrom: i = null, signal: u = null, withArrayMethodDescriptors: c = !1, honourDoneMutationFlags: l = !1, ...d } = e; return r || (r = `${t}-${(0 | Math.random() * 9e6).toString(36)}`), !o && !f && g(n) && s && !t?.endsWith(".mutate") && (lt.call(this, n, r, { signal: u, withArrayMethodDescriptors: c, honourDoneMutationFlags: l }), o = !0), { portOptions: d, wqOptions: { type: t, eventID: r, live: s, observing: o, honourDoneMutationFlags: l, bubbles: a, forwarded: f, relayedFrom: i } } } function lt(n, e, { signal: t, withArrayMethodDescriptors: r = !0, honourDoneMutationFlags: s = !1 } = {}) { if (!g(n)) throw new TypeError("data must be a plain object and not a stream"); if (typeof e != "string") throw new TypeError("eventID must be a non-empty string"); let o = i => { let u; r && Array.isArray(i[0].target) && !i[0].argumentsList && !["set", "defineProperty", "deleteProperty"].includes(i[0].operation) || (this.postMessage(i.map(c => (u = !u && s && c.detail?.done, { ...c, target: void 0 })), { type: `${e}.mutate` }), u && a.abort()) }, a = j.observe(n, j.subtree(), o, { signal: t, withArrayMethodDescriptors: r }); return te.call(this).add(a), a } function Le(n, e, { signal: t, honourDoneMutationFlags: r = !1 } = {}) { if (!g(n)) throw new TypeError("data must be a plain object and not a stream"); if (typeof e != "string") throw new TypeError("eventID must be a non-empty string"); let s = f => { if (!f.data?.length) return; let i; j.batch(n, () => { for (let u of f.data) { if (i = !i && r && u.detail?.done, u.argumentsList) { let c = u.path.length ? j.get(n, j.path(...u.path)) : n; j.proxy(c)[u.operation](...u.argumentsList); continue } if (u.key !== "length" || ["set", "defineProperty", "deleteProperty"].includes(u.operation)) { let c = u.path.length === 1 ? n : j.get(n, j.path(...u.path.slice(0, -1))); u.type === "delete" ? j.deleteProperty(c, u.key) : j.set(c, u.key, u.value) } } }), i && o() }; this.addEventListener(`${e}.mutate`, s, { signal: t }); let o = () => this.removeEventListener(`${e}.mutate`, s); return te.call(this).add(o), o } var me = class extends Oe(BroadcastChannel) { constructor(e, { autoStart: t = !0, postAwaitsOpen: r = !1, clientServerMode: s = null, autoClose: o = !0 } = {}) { super(e); let a = E(this); if (s && !["server", "client"].includes(s)) throw new Error('clientServerMode must be "server" or "client"'); a.set("options", { autoStart: t, postAwaitsOpen: r, clientServerMode: s, autoClose: o }), this.constructor.upgradeEvents(this) } __postMessage(e, t) { BroadcastChannel.prototype.postMessage.call(this, e) } }; var Ae = class n extends EventTarget { static get xHeaderName() { return "X-Message-Port" } static test(e) { return e instanceof n || e?.[Symbol.toStringTag] === "LiveResponse" ? "LiveResponse" : e?.[Symbol.toStringTag] === "LiveProgramHandle" ? "LiveProgramHandle" : e instanceof Response ? "Response" : Vt(e) ? "Generator" : "Default" } static hasBackgroundPort(e) { return !!e.headers?.get?.(this.xHeaderName)?.trim() } static getBackgroundPort(e) { if (!/Response/.test(this.test(e))) return; let t = M(e); if (!t.has("background_port")) { let r = e.headers.get(this.xHeaderName)?.trim(); if (!r) return; let [s, o] = r.split(":"); if (!["ws", "br"].includes(s)) throw new Error(`Unknown background messaging protocol: ${r}`); let a = s === "br" ? new me(o, { autoStart: !1, postAwaitsOpen: !0, clientServerMode: "client" }) : new ee(o, { autoStart: !1, naturalOpen: !1, postAwaitsOpen: !0 }); t.set("background_port", a) } return t.get("background_port") } static from(e, ...t) { return this.test(e) === "LiveResponse" ? e.clone(...t) : new this(e, ...t) } [Symbol.toStringTag] = "LiveResponse"; constructor(e, ...t) { super(), this.#r(e, ...t) } #t = null; get body() { return this.#t } get bodyUsed() { return !1 } #s = new T; get headers() { return this.#s } #n = 200; get status() { return this.#n } #i = ""; get statusText() { return this.#i } #u = "basic"; get type() { return this.#u } #c = !1; get redirected() { return this.#c } #a = null; get url() { return this.#a } get ok() { return this.#n >= 200 && this.#n < 299 } async arrayBuffer() { throw new Error("LiveResponse does not support the arrayBuffer() method.") } async formData() { throw new Error("LiveResponse does not support the formData() method.") } async json() { throw new Error("LiveResponse does not support the json() method.") } async text() { throw new Error("LiveResponse does not support the text() method.") } async blob() { throw new Error("LiveResponse does not support the blob() method.") } async bytes() { throw new Error("LiveResponse does not support the bytes() method.") } get background() { return this.constructor.getBackgroundPort(this) } #e = new AbortController; get signal() { return this.#e.signal } get readyState() { let e = Me.call(this); return e.done.state ? "done" : e.live.state ? "live" : "waiting" } readyStateChange(e) { if (!["live", "done"].includes(e)) throw new Error(`Invalid readyState query "${e}"`); return Me.call(this)[e].promise } disconnect() { this.#e.abort(), this.#e = new AbortController } #o; #f(e) { let t = Me.call(this); if (t.done.state) throw new Error("Response already done."); this.#o = e, e.then(r => { this.#o === e && (this.#o = null, t.done.state = !0, t.done.resolve(r)) }).catch(r => { this.#o === e && (this.#o = null, t.done.state = !0, t.done.reject(r)) }) } async replaceWith(e, ...t) { if (this.readyState === "done") throw new Error("Response already done."); this.disconnect(), await this.#r(e, ...t) } async#r(e, ...t) { if (e instanceof Promise) return this.#f(e), await new Promise((l, d) => { let h = !1; this.#e.signal.addEventListener("abort", () => { h = !0, l() }), e.then(async p => { h || (await this.#r(p, ...t), l()) }), e.catch(p => d(p)) }); let r = l => { let d = l.body; this.#n = l.status, this.#i = l.statusText; for (let [p] of [...this.#s.entries()]) this.#s.delete(p); for (let [p, m] of l.headers.entries()) this.#s.append(p, m); this.#u = l.type, this.#c = l.redirected, this.#a = l.url, this.#t = d, z.defineProperty(this, "body", { get: () => this.#t, enumerable: !1, configurable: !0 }); let h = Me.call(this); h.live.state = !0, h.live.resolve(), this.dispatchEvent(new Event("replace")) }, s = async (l, d) => { r({ body: l, status: 200, statusText: "", headers: new Headers, ...d, type: "basic", redirected: !1, url: null }) }, o = async (l, d) => { let h, p = !1; try { h = l instanceof Response ? await N.prototype.parse.call(l, { to: "json" }) : l.body, p = !0 } catch { h = l.body } if (r({ body: h, status: l.status, statusText: l.statusText, headers: l.headers, ...d, type: l.type, redirected: l.redirected, url: l.url }), this.constructor.test(l) === "LiveResponse") return l.addEventListener("replace", () => { r(l) }, { signal: this.#e.signal }), await l.readyStateChange("done"); if (this.hasBackgroundPort(l)) { let m = this.constructor.getBackgroundPort(l), w; return p && (w = c.projectMutations({ from: "initial_response", to: h, signal: this.#e.signal })), m.addEventListener("response.replace", x => { w?.(), w = null, r(x.data) }, { signal: this.#e.signal }), await m.readyStateChange("close") } return Promise.resolve() }, a = async (l, d) => { let h = await l.next(), p = await h.value; await this.#r(p, { done: h.done, ...d }); let m = h, w = p; for (; !m.done && !this.#e.signal.aborted;)m = await l.next(), w = await m.value, this.#e.signal.aborted || await this.#r(w, { done: d.done === !1 ? !1 : m.done }) }, f = async (l, d) => (await this.#r(l.value, d), z.observe(l, "value", h => this.#r(h.value, { done: !1 }), { signal: this.#e.signal }), new Promise(() => { })), i = b(t[0]) ? { ...t.shift() } : {}, u = typeof t[0] == "function" ? t.shift() : null; if ("status" in i && (i.status = parseInt(i.status), i.status < 200 || i.status > 599)) throw new Error(`The status provided (${i.status}) is outside the range [200, 599].`); "statusText" in i && (i.statusText = String(i.statusText)), i.headers && !(i.headers instanceof Headers) && (i.headers = new Headers(i.headers)); let c; if (/Response/.test(this.constructor.test(e))) { if (u) throw new Error("frameClosure is not supported for responses."); c = await o(e, i) } else if (this.constructor.test(e) === "Generator") { if (u) throw new Error("frameClosure is not supported for generators."); c = await a(e, i) } else if (this.constructor.test(e) === "LiveProgramHandle") { if (u) throw new Error("frameClosure is not supported for live program handles."); c = await f(e, i) } else if (c = s(e, i), u) { let l = g(e) && !De(e) ? z.proxy(e, { chainable: !0, membrane: e }) : e; c = Promise.resolve(u.call(this, l)) } return this.#f(i.done === !1 ? new Promise(() => { }) : c), await new Promise((l, d) => { this.#e.signal.addEventListener("abort", l), c.then(() => l()), c.catch(h => d(h)) }) } toResponse({ client: e, signal: t } = {}) { if (e && !(e instanceof O)) throw new Error("Client must be a MessagePortPlus interface"); let r = N.from(this.body, { status: this.status, statusText: this.statusText, headers: this.headers }), s = M(this); if (K(r).set("meta", s), e && this.readyState === "live") { let o; g(this.body) && !De(this.body) && (o = e.projectMutations({ from: this.body, to: "initial_response", signal: t })); let a = () => { o?.(), o = null; let f = Object.fromEntries([...this.headers.entries()]); f?.["set-cookie"] && (delete f["set-cookie"], console.warn('Warning: The "set-cookie" header is not supported for security reasons and has been removed from the response.')), e.postMessage({ body: this.body, status: this.status, statusText: this.statusText, headers: f, done: this.readyState === "done" }, { type: "response.replace", live: !0, signal: this.#e.signal }) }; this.addEventListener("replace", a, { signal: t }) } return r } async*toGenerator({ signal: e } = {}) { do yield this.body; while (await new Promise(t => { this.addEventListener("replace", () => t(!0), { once: !0, signal: e }), this.readyStateChange("done").then(() => t(!1)) })) } toLiveProgramHandle({ signal: e } = {}) { let t = new Ze, r = () => z.defineProperty(t, "value", { value: this.body, enumerable: !0, configurable: !0 }); return this.addEventListener("replace", r, { signal: e }), r(), t } clone(e = {}) { let t = new this.constructor, r = M(this); return K(t).set("meta", r), t.replaceWith(this, e), t } }, Vt = n => typeof n?.next == "function" && typeof n?.throw == "function" && typeof n?.return == "function"; function Me() { let n = M(this); if (!n.has("readystate_registry")) { let e = t => (t.promise = new Promise((r, s) => (t.resolve = () => r(this), t.reject = s)), t); n.set("readystate_registry", { live: e({}), done: e({}) }) } return n.get("readystate_registry") } var Ze = class { [Symbol.toStringTag] = "LiveProgramHandle"; abort() { } }; globalThis.webqit || (globalThis.webqit = {}); Object.assign(globalThis.webqit, Xe); })();
//# sourceMappingURL=main.js.map
